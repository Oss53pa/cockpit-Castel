// ============================================================================
// PROPH3T ENGINE V2 â€” PROJECT JOURNAL
// Journal de bord automatique du projet
// ============================================================================

import type { Action, Jalon, Risque } from '../../../types';

// ============================================================================
// TYPES
// ============================================================================

export type JournalEntryType =
  | 'milestone_completed'
  | 'milestone_delayed'
  | 'action_completed'
  | 'action_blocked'
  | 'risk_identified'
  | 'risk_mitigated'
  | 'decision_made'
  | 'issue_raised'
  | 'issue_resolved'
  | 'budget_alert'
  | 'schedule_alert'
  | 'team_update'
  | 'external_event'
  | 'lesson_learned'
  | 'manual_note';

export type JournalEntryImportance = 'critical' | 'high' | 'medium' | 'low';

export interface JournalEntry {
  id: string;
  type: JournalEntryType;
  timestamp: Date;
  title: string;
  content: string;
  importance: JournalEntryImportance;
  category: string;
  tags: string[];
  linkedEntities: Array<{ type: string; id: string; name: string }>;
  author?: string;
  isAutoGenerated: boolean;
  metrics?: Record<string, number | string>;
  attachments?: string[];
}

export interface JournalFilter {
  types?: JournalEntryType[];
  importance?: JournalEntryImportance[];
  dateFrom?: Date;
  dateTo?: Date;
  category?: string;
  tags?: string[];
  searchText?: string;
}

export interface JournalSummary {
  period: { start: Date; end: Date };
  totalEntries: number;
  byType: Record<JournalEntryType, number>;
  byImportance: Record<JournalEntryImportance, number>;
  highlights: JournalEntry[];
  timeline: Array<{ date: Date; count: number; types: JournalEntryType[] }>;
}

export interface JournalExport {
  title: string;
  period: { start: Date; end: Date };
  summary: string;
  entries: JournalEntry[];
  generatedAt: Date;
  format: 'markdown' | 'html' | 'json';
}

// ============================================================================
// PROJECT JOURNAL
// ============================================================================

export class ProjectJournal {
  private entries: Map<string, JournalEntry> = new Map();

  // ---------------------------------------------------------------------------
  // CRÃ‰ATION D'ENTRÃ‰ES
  // ---------------------------------------------------------------------------

  addEntry(entry: Omit<JournalEntry, 'id' | 'timestamp' | 'isAutoGenerated'>): JournalEntry {
    const id = `journal-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;

    const fullEntry: JournalEntry = {
      ...entry,
      id,
      timestamp: new Date(),
      isAutoGenerated: false,
    };

    this.entries.set(id, fullEntry);
    return fullEntry;
  }

  /**
   * GÃ©nÃ¨re automatiquement une entrÃ©e basÃ©e sur un Ã©vÃ©nement projet
   */
  autoGenerateEntry(
    type: JournalEntryType,
    data: {
      title: string;
      content: string;
      importance?: JournalEntryImportance;
      linkedEntities?: Array<{ type: string; id: string; name: string }>;
      metrics?: Record<string, number | string>;
    }
  ): JournalEntry {
    const id = `journal-auto-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;

    const entry: JournalEntry = {
      id,
      type,
      timestamp: new Date(),
      title: data.title,
      content: data.content,
      importance: data.importance || this.inferImportance(type),
      category: this.inferCategory(type),
      tags: this.inferTags(type),
      linkedEntities: data.linkedEntities || [],
      isAutoGenerated: true,
      metrics: data.metrics,
    };

    this.entries.set(id, entry);
    return entry;
  }

  private inferImportance(type: JournalEntryType): JournalEntryImportance {
    const mapping: Record<JournalEntryType, JournalEntryImportance> = {
      milestone_completed: 'high',
      milestone_delayed: 'critical',
      action_completed: 'medium',
      action_blocked: 'high',
      risk_identified: 'high',
      risk_mitigated: 'medium',
      decision_made: 'high',
      issue_raised: 'high',
      issue_resolved: 'medium',
      budget_alert: 'critical',
      schedule_alert: 'critical',
      team_update: 'low',
      external_event: 'medium',
      lesson_learned: 'medium',
      manual_note: 'low',
    };
    return mapping[type];
  }

  private inferCategory(type: JournalEntryType): string {
    if (type.includes('milestone') || type.includes('schedule')) return 'Planning';
    if (type.includes('action')) return 'ExÃ©cution';
    if (type.includes('risk')) return 'Risques';
    if (type.includes('budget')) return 'Budget';
    if (type.includes('decision')) return 'Gouvernance';
    if (type.includes('issue')) return 'ProblÃ¨mes';
    if (type.includes('team')) return 'Ã‰quipe';
    return 'GÃ©nÃ©ral';
  }

  private inferTags(type: JournalEntryType): string[] {
    const tags: string[] = [type];
    if (type.includes('completed') || type.includes('resolved') || type.includes('mitigated')) {
      tags.push('positif');
    }
    if (type.includes('delayed') || type.includes('blocked') || type.includes('alert')) {
      tags.push('attention');
    }
    return tags;
  }

  // ---------------------------------------------------------------------------
  // DÃ‰TECTION AUTOMATIQUE D'Ã‰VÃ‰NEMENTS
  // ---------------------------------------------------------------------------

  /**
   * Analyse les donnÃ©es projet et gÃ©nÃ¨re automatiquement les entrÃ©es de journal
   */
  detectAndLogEvents(
    currentData: { actions: Action[]; jalons: Jalon[]; risques: Risque[] },
    previousData?: { actions: Action[]; jalons: Jalon[]; risques: Risque[] }
  ): JournalEntry[] {
    const newEntries: JournalEntry[] = [];

    // DÃ©tecter les jalons complÃ©tÃ©s
    for (const jalon of currentData.jalons) {
      if (jalon.statut === 'termine') {
        const prev = previousData?.jalons.find(j => j.id_jalon === jalon.id_jalon);
        if (!prev || prev.statut !== 'termine') {
          newEntries.push(this.autoGenerateEntry('milestone_completed', {
            title: `Jalon atteint: ${jalon.nom}`,
            content: `Le jalon "${jalon.nom}" a Ã©tÃ© marquÃ© comme terminÃ©.`,
            linkedEntities: [{ type: 'jalon', id: jalon.id_jalon, name: jalon.nom }],
          }));
        }
      }
    }

    // DÃ©tecter les jalons en retard
    const now = new Date();
    for (const jalon of currentData.jalons) {
      if (jalon.statut !== 'termine' && jalon.date_prevue && new Date(jalon.date_prevue) < now) {
        const prev = previousData?.jalons.find(j => j.id_jalon === jalon.id_jalon);
        const prevDate = prev?.date_prevue ? new Date(prev.date_prevue) : null;
        if (!prevDate || prevDate >= now) {
          newEntries.push(this.autoGenerateEntry('milestone_delayed', {
            title: `Jalon en retard: ${jalon.nom}`,
            content: `Le jalon "${jalon.nom}" a dÃ©passÃ© sa date prÃ©vue (${new Date(jalon.date_prevue).toLocaleDateString('fr-FR')}).`,
            importance: 'critical',
            linkedEntities: [{ type: 'jalon', id: jalon.id_jalon, name: jalon.nom }],
          }));
        }
      }
    }

    // DÃ©tecter les actions bloquÃ©es
    for (const action of currentData.actions) {
      if (action.statut === 'bloque') {
        const prev = previousData?.actions.find(a => a.id_action === action.id_action);
        if (!prev || prev.statut !== 'bloque') {
          newEntries.push(this.autoGenerateEntry('action_blocked', {
            title: `Action bloquÃ©e: ${action.nom}`,
            content: `L'action "${action.nom}" est maintenant bloquÃ©e.`,
            linkedEntities: [{ type: 'action', id: action.id_action, name: action.nom }],
          }));
        }
      }
    }

    // DÃ©tecter les nouveaux risques critiques
    for (const risque of currentData.risques) {
      if (risque.statut === 'actif' && risque.criticite && risque.criticite >= 15) {
        const prev = previousData?.risques.find(r => r.id_risque === risque.id_risque);
        if (!prev) {
          newEntries.push(this.autoGenerateEntry('risk_identified', {
            title: `Risque critique identifiÃ©`,
            content: risque.description || 'Nouveau risque de niveau critique',
            importance: 'critical',
            linkedEntities: [{ type: 'risque', id: risque.id_risque, name: risque.description?.substring(0, 50) || 'Risque' }],
            metrics: { criticite: risque.criticite },
          }));
        }
      }
    }

    return newEntries;
  }

  // ---------------------------------------------------------------------------
  // REQUÃŠTES
  // ---------------------------------------------------------------------------

  getEntry(id: string): JournalEntry | undefined {
    return this.entries.get(id);
  }

  getAllEntries(): JournalEntry[] {
    return Array.from(this.entries.values())
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }

  searchEntries(filter: JournalFilter): JournalEntry[] {
    return this.getAllEntries().filter(entry => {
      if (filter.types && !filter.types.includes(entry.type)) return false;
      if (filter.importance && !filter.importance.includes(entry.importance)) return false;
      if (filter.dateFrom && new Date(entry.timestamp) < filter.dateFrom) return false;
      if (filter.dateTo && new Date(entry.timestamp) > filter.dateTo) return false;
      if (filter.category && entry.category !== filter.category) return false;
      if (filter.tags && !filter.tags.some(t => entry.tags.includes(t))) return false;
      if (filter.searchText) {
        const searchLower = filter.searchText.toLowerCase();
        if (!entry.title.toLowerCase().includes(searchLower) &&
            !entry.content.toLowerCase().includes(searchLower)) {
          return false;
        }
      }
      return true;
    });
  }

  getEntriesForPeriod(start: Date, end: Date): JournalEntry[] {
    return this.searchEntries({ dateFrom: start, dateTo: end });
  }

  getRecentEntries(days: number = 7): JournalEntry[] {
    const start = new Date();
    start.setDate(start.getDate() - days);
    return this.searchEntries({ dateFrom: start });
  }

  // ---------------------------------------------------------------------------
  // RÃ‰SUMÃ‰S
  // ---------------------------------------------------------------------------

  generateSummary(start: Date, end: Date): JournalSummary {
    const entries = this.getEntriesForPeriod(start, end);

    const byType: Record<JournalEntryType, number> = {} as any;
    const byImportance: Record<JournalEntryImportance, number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
    };

    for (const entry of entries) {
      byType[entry.type] = (byType[entry.type] || 0) + 1;
      byImportance[entry.importance]++;
    }

    // Highlights: entrÃ©es les plus importantes
    const highlights = entries
      .filter(e => e.importance === 'critical' || e.importance === 'high')
      .slice(0, 5);

    // Timeline: agrÃ©gation par jour
    const timelineMap = new Map<string, { date: Date; count: number; types: Set<JournalEntryType> }>();
    for (const entry of entries) {
      const dateKey = new Date(entry.timestamp).toISOString().split('T')[0];
      const existing = timelineMap.get(dateKey) || {
        date: new Date(dateKey),
        count: 0,
        types: new Set<JournalEntryType>(),
      };
      existing.count++;
      existing.types.add(entry.type);
      timelineMap.set(dateKey, existing);
    }

    const timeline = Array.from(timelineMap.values())
      .map(t => ({ ...t, types: Array.from(t.types) }))
      .sort((a, b) => a.date.getTime() - b.date.getTime());

    return {
      period: { start, end },
      totalEntries: entries.length,
      byType,
      byImportance,
      highlights,
      timeline,
    };
  }

  // ---------------------------------------------------------------------------
  // EXPORT
  // ---------------------------------------------------------------------------

  export(filter: JournalFilter, format: 'markdown' | 'html' | 'json'): JournalExport {
    const entries = this.searchEntries(filter);
    const period = {
      start: filter.dateFrom || new Date(Math.min(...entries.map(e => new Date(e.timestamp).getTime()))),
      end: filter.dateTo || new Date(),
    };

    let summary = `${entries.length} entrÃ©es du ${period.start.toLocaleDateString('fr-FR')} au ${period.end.toLocaleDateString('fr-FR')}`;

    const criticalCount = entries.filter(e => e.importance === 'critical').length;
    if (criticalCount > 0) {
      summary += `. ${criticalCount} Ã©vÃ©nement(s) critique(s).`;
    }

    return {
      title: 'Journal de Projet',
      period,
      summary,
      entries,
      generatedAt: new Date(),
      format,
    };
  }

  exportToMarkdown(filter: JournalFilter): string {
    const data = this.export(filter, 'markdown');
    const lines: string[] = [];

    lines.push(`# ${data.title}`);
    lines.push(`*PÃ©riode: ${data.period.start.toLocaleDateString('fr-FR')} - ${data.period.end.toLocaleDateString('fr-FR')}*`);
    lines.push('');
    lines.push(`## RÃ©sumÃ©`);
    lines.push(data.summary);
    lines.push('');
    lines.push(`## EntrÃ©es`);
    lines.push('');

    for (const entry of data.entries) {
      const icon = this.getEntryIcon(entry.type);
      lines.push(`### ${icon} ${entry.title}`);
      lines.push(`*${new Date(entry.timestamp).toLocaleString('fr-FR')} - ${entry.importance}*`);
      lines.push('');
      lines.push(entry.content);
      if (entry.tags.length > 0) {
        lines.push('');
        lines.push(`Tags: ${entry.tags.map(t => `\`${t}\``).join(', ')}`);
      }
      lines.push('');
      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  private getEntryIcon(type: JournalEntryType): string {
    const icons: Record<JournalEntryType, string> = {
      milestone_completed: 'âœ…',
      milestone_delayed: 'âš ï¸',
      action_completed: 'âœ“',
      action_blocked: 'ğŸš«',
      risk_identified: 'âš¡',
      risk_mitigated: 'ğŸ›¡ï¸',
      decision_made: 'ğŸ“‹',
      issue_raised: 'â—',
      issue_resolved: 'âœ”ï¸',
      budget_alert: 'ğŸ’°',
      schedule_alert: 'â°',
      team_update: 'ğŸ‘¥',
      external_event: 'ğŸŒ',
      lesson_learned: 'ğŸ’¡',
      manual_note: 'ğŸ“',
    };
    return icons[type] || 'ğŸ“Œ';
  }

  // ---------------------------------------------------------------------------
  // GESTION
  // ---------------------------------------------------------------------------

  updateEntry(id: string, updates: Partial<JournalEntry>): JournalEntry | null {
    const entry = this.entries.get(id);
    if (!entry) return null;

    const updated = { ...entry, ...updates };
    this.entries.set(id, updated);
    return updated;
  }

  deleteEntry(id: string): boolean {
    return this.entries.delete(id);
  }

  clearOldEntries(olderThan: Date): number {
    let deleted = 0;
    for (const [id, entry] of this.entries) {
      if (new Date(entry.timestamp) < olderThan) {
        this.entries.delete(id);
        deleted++;
      }
    }
    return deleted;
  }

  // ---------------------------------------------------------------------------
  // IMPORT/EXPORT DATA
  // ---------------------------------------------------------------------------

  exportData(): JournalEntry[] {
    return this.getAllEntries();
  }

  importData(entries: JournalEntry[]): void {
    for (const entry of entries) {
      this.entries.set(entry.id, entry);
    }
  }
}

export default ProjectJournal;
