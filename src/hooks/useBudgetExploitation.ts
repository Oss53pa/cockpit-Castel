/**
 * Hook pour la gestion des budgets d'exploitation
 * Permet de lire, modifier et sauvegarder les lignes budgétaires
 */

import { useState, useCallback, useEffect, useRef } from 'react';
import { useLiveQuery } from 'dexie-react-hooks';
import { db } from '@/db';
import type {
  LigneBudgetExploitation,
  BudgetExploitationType,
  DEFAULT_POSTES_EXPLOITATION_2027,
  DEFAULT_POSTES_MOBILISATION,
} from '@/types/budgetExploitation.types';

// Verrou global pour empêcher les initialisations concurrentes (par budgetType+annee)
const initializationLocks = new Map<string, Promise<void>>();

// Fonction pour nettoyer les doublons (utilisable en dehors du hook)
async function cleanupDuplicates(budgetType: BudgetExploitationType, annee: number): Promise<number> {
  const existingLignes = await db.budgetExploitation
    .where('budgetType')
    .equals(budgetType)
    .and((l) => l.annee === annee)
    .toArray();

  if (existingLignes.length === 0) return 0;

  const seenPostes = new Set<string>();
  const duplicateIds: number[] = [];

  for (const ligne of existingLignes) {
    if (seenPostes.has(ligne.poste)) {
      if (ligne.id) duplicateIds.push(ligne.id);
    } else {
      seenPostes.add(ligne.poste);
    }
  }

  if (duplicateIds.length > 0) {
    console.log(`[Budget] Suppression de ${duplicateIds.length} doublons pour ${budgetType} ${annee}`);
    await db.budgetExploitation.bulkDelete(duplicateIds);
  }

  return duplicateIds.length;
}

// Données par défaut pour chaque type de budget
const getDefaultData = (budgetType: BudgetExploitationType, annee: number): Omit<LigneBudgetExploitation, 'id' | 'createdAt' | 'updatedAt'>[] => {
  if (budgetType === 'exploitation2027') {
    return [
      { budgetType, annee: 2027, ordre: 1, poste: 'Masse salariale', description: '25 personnes stabilisées', categorie: 'masse_salariale', montantPrevu: 165_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#3B82F6' },
      { budgetType, annee: 2027, ordre: 2, poste: 'Prestations externalisées', description: 'Sécurité 145M, Nettoyage 100M, Maintenance 50M', categorie: 'prestations', montantPrevu: 295_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#10B981' },
      { budgetType, annee: 2027, ordre: 3, poste: 'Fluides & Énergies', description: '1.1M kWh électricité, 20k m³ eau', categorie: 'fluides', montantPrevu: 160_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#F59E0B' },
      { budgetType, annee: 2027, ordre: 4, poste: 'Assurances', description: 'Multi-risque, RC, Perte exploitation', categorie: 'assurances', montantPrevu: 26_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#8B5CF6' },
      { budgetType, annee: 2027, ordre: 5, poste: 'Fonctionnement', description: 'Bureau, Télécom, Honoraires', categorie: 'fonctionnement', montantPrevu: 24_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#6366F1' },
      { budgetType, annee: 2027, ordre: 6, poste: 'Marketing & Communication', description: '4 événements majeurs, Digital, RP', categorie: 'marketing', montantPrevu: 35_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#EC4899' },
      { budgetType, annee: 2027, ordre: 7, poste: 'Provisions', description: 'Gros entretien, Créances douteuses, Litiges', categorie: 'provisions', montantPrevu: 20_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#14B8A6' },
      { budgetType, annee: 2027, ordre: 8, poste: 'Contingence (5%)', description: '5% sur total postes 1-7', categorie: 'contingence', montantPrevu: 36_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#F97316' },
    ];
  }

  if (budgetType === 'mobilisation') {
    return [
      { budgetType, annee: 2026, ordre: 1, poste: 'Recrutement', description: 'Frais de recrutement et salaires équipe pilote', categorie: 'recrutement', montantPrevu: 118_000_000, montantEngage: 112_000_000, montantConsomme: 81_500_000, couleur: '#3B82F6' },
      { budgetType, annee: 2026, ordre: 2, poste: 'Formation', description: 'Formation initiale et externe', categorie: 'formation', montantPrevu: 40_000_000, montantEngage: 35_000_000, montantConsomme: 23_000_000, couleur: '#22C55E' },
      { budgetType, annee: 2026, ordre: 3, poste: 'Marketing', description: 'Identité visuelle, site web, campagne pré-ouverture', categorie: 'marketing', montantPrevu: 100_000_000, montantEngage: 75_000_000, montantConsomme: 48_000_000, couleur: '#8B5CF6' },
      { budgetType, annee: 2026, ordre: 4, poste: 'Événements', description: 'Soft Opening, Inauguration, Animations M1', categorie: 'evenements', montantPrevu: 100_000_000, montantEngage: 45_000_000, montantConsomme: 0, couleur: '#F59E0B' },
      { budgetType, annee: 2026, ordre: 5, poste: 'IT & Équipements', description: 'Systèmes informatiques, matériel, signalétique', categorie: 'it_equipements', montantPrevu: 72_000_000, montantEngage: 67_000_000, montantConsomme: 53_000_000, couleur: '#06B6D4' },
      { budgetType, annee: 2026, ordre: 6, poste: 'Aménagement', description: 'Mobilier bureaux et espaces', categorie: 'amenagement', montantPrevu: 33_000_000, montantEngage: 33_000_000, montantConsomme: 30_000_000, couleur: '#F97316' },
      { budgetType, annee: 2026, ordre: 7, poste: 'Frais généraux', description: 'Déplacements, fournitures, assurances', categorie: 'frais_generaux', montantPrevu: 40_000_000, montantEngage: 32_000_000, montantConsomme: 25_000_000, couleur: '#64748B' },
      { budgetType, annee: 2026, ordre: 8, poste: 'Provisions', description: 'Imprévus et réserve de trésorerie', categorie: 'provisions', montantPrevu: 65_500_000, montantEngage: 0, montantConsomme: 0, couleur: '#71717A' },
    ];
  }

  if (budgetType === 'operationnel') {
    return [
      { budgetType, annee, ordre: 1, poste: 'Masse salariale', description: `${annee === 2026 ? '20' : '25'} personnes`, categorie: 'masse_salariale', montantPrevu: annee === 2026 ? 98_500_000 : 165_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#3B82F6' },
      { budgetType, annee, ordre: 2, poste: 'Prestations', description: 'Sécurité, Nettoyage, Maintenance', categorie: 'prestations', montantPrevu: annee === 2026 ? 49_000_000 : 295_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#10B981' },
      { budgetType, annee, ordre: 3, poste: 'Fluides & Énergies', description: 'Électricité, Eau, Carburant', categorie: 'fluides', montantPrevu: annee === 2026 ? 28_000_000 : 160_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#F59E0B' },
      { budgetType, annee, ordre: 4, poste: 'Assurances', description: 'Multi-risque, RC', categorie: 'assurances', montantPrevu: annee === 2026 ? 5_000_000 : 26_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#8B5CF6' },
      { budgetType, annee, ordre: 5, poste: 'Fonctionnement', description: 'Bureau, Télécom, Honoraires', categorie: 'fonctionnement', montantPrevu: annee === 2026 ? 4_000_000 : 24_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#6366F1' },
      { budgetType, annee, ordre: 6, poste: 'Marketing', description: 'Communication, Événements', categorie: 'marketing', montantPrevu: annee === 2026 ? 6_000_000 : 35_000_000, montantEngage: 0, montantConsomme: 0, couleur: '#EC4899' },
      { budgetType, annee, ordre: 7, poste: 'Provisions', description: 'Gros entretien, Litiges', categorie: 'provisions', montantPrevu: annee === 2027 ? 20_000_000 : 0, montantEngage: 0, montantConsomme: 0, couleur: '#14B8A6' },
      { budgetType, annee, ordre: 8, poste: 'Contingence', description: '5% imprévus', categorie: 'contingence', montantPrevu: annee === 2027 ? 36_000_000 : 0, montantEngage: 0, montantConsomme: 0, couleur: '#F97316' },
    ];
  }

  // Default for estimatif
  return [];
};

interface UseBudgetExploitationOptions {
  budgetType: BudgetExploitationType;
  annee?: number;
  siteId?: number;
}

interface UseBudgetExploitationReturn {
  lignes: LigneBudgetExploitation[];
  isLoading: boolean;
  error: string | null;
  totaux: {
    prevu: number;
    engage: number;
    consomme: number;
    reste: number;
  };

  // Actions
  updateLigne: (id: number, updates: Partial<LigneBudgetExploitation>) => Promise<void>;
  updateMontants: (id: number, prevu: number, engage: number, consomme: number) => Promise<void>;
  addLigne: (ligne: Omit<LigneBudgetExploitation, 'id' | 'createdAt' | 'updatedAt'>) => Promise<number>;
  deleteLigne: (id: number) => Promise<void>;
  resetToDefaults: () => Promise<void>;
  initializeIfEmpty: () => Promise<void>;
}

export function useBudgetExploitation({
  budgetType,
  annee = 2027,
  siteId = 1,
}: UseBudgetExploitationOptions): UseBudgetExploitationReturn {
  const [error, setError] = useState<string | null>(null);
  const hasInitializedRef = useRef(false);

  // Requête live vers la base de données
  const lignes = useLiveQuery(
    async () => {
      const results = await db.budgetExploitation
        .where('budgetType')
        .equals(budgetType)
        .and((ligne) => ligne.annee === annee)
        .sortBy('ordre');
      return results;
    },
    [budgetType, annee],
    []
  );

  const isLoading = lignes === undefined;

  // Calcul des totaux
  const totaux = {
    prevu: (lignes || []).reduce((sum, l) => sum + (l.montantPrevu || 0), 0),
    engage: (lignes || []).reduce((sum, l) => sum + (l.montantEngage || 0), 0),
    consomme: (lignes || []).reduce((sum, l) => sum + (l.montantConsomme || 0), 0),
    reste: 0,
  };
  totaux.reste = totaux.prevu - totaux.consomme;

  // Initialiser les données si la table est vide et nettoyer les doublons
  // Utilise un verrou global pour empêcher les initialisations concurrentes
  const initializeIfEmpty = useCallback(async () => {
    // Vérifier si déjà initialisé pour cette instance
    if (hasInitializedRef.current) return;
    hasInitializedRef.current = true;

    const lockKey = `${budgetType}-${annee}`;

    // Vérifier si une initialisation est déjà en cours pour ce budgetType+annee
    const existingLock = initializationLocks.get(lockKey);
    if (existingLock) {
      // Attendre la fin de l'initialisation en cours
      await existingLock;
      return;
    }

    // Créer un nouveau verrou
    const initPromise = (async () => {
      try {
        // D'abord nettoyer les doublons existants
        await cleanupDuplicates(budgetType, annee);

        // Vérifier si des données existent après nettoyage
        const countAfterCleanup = await db.budgetExploitation
          .where('budgetType')
          .equals(budgetType)
          .and((l) => l.annee === annee)
          .count();

        if (countAfterCleanup === 0) {
          const now = new Date().toISOString();
          const defaultData = getDefaultData(budgetType, annee);

          if (defaultData.length > 0) {
            const lignesWithTimestamps = defaultData.map((ligne) => ({
              ...ligne,
              siteId,
              createdAt: now,
              updatedAt: now,
            }));

            await db.budgetExploitation.bulkAdd(lignesWithTimestamps as LigneBudgetExploitation[]);
            console.log(`[Budget] Initialisation de ${defaultData.length} lignes pour ${budgetType} ${annee}`);
          }
        }
      } catch (err) {
        console.error('Erreur initialisation budget:', err);
        setError('Erreur lors de l\'initialisation du budget');
      } finally {
        // Supprimer le verrou après un court délai pour éviter les conditions de course
        setTimeout(() => {
          initializationLocks.delete(lockKey);
        }, 100);
      }
    })();

    initializationLocks.set(lockKey, initPromise);
    await initPromise;
  }, [budgetType, annee, siteId]);

  // Initialiser au chargement
  useEffect(() => {
    initializeIfEmpty();
  }, [initializeIfEmpty]);

  // Mettre à jour une ligne
  const updateLigne = useCallback(
    async (id: number, updates: Partial<LigneBudgetExploitation>) => {
      try {
        await db.budgetExploitation.update(id, {
          ...updates,
          updatedAt: new Date().toISOString(),
        });
        setError(null);
      } catch (err) {
        console.error('Erreur mise à jour ligne:', err);
        setError('Erreur lors de la mise à jour');
        throw err;
      }
    },
    []
  );

  // Mettre à jour les montants (raccourci)
  const updateMontants = useCallback(
    async (id: number, prevu: number, engage: number, consomme: number) => {
      await updateLigne(id, {
        montantPrevu: prevu,
        montantEngage: engage,
        montantConsomme: consomme,
      });
    },
    [updateLigne]
  );

  // Ajouter une ligne
  const addLigne = useCallback(
    async (ligne: Omit<LigneBudgetExploitation, 'id' | 'createdAt' | 'updatedAt'>) => {
      try {
        const now = new Date().toISOString();
        const id = await db.budgetExploitation.add({
          ...ligne,
          siteId,
          createdAt: now,
          updatedAt: now,
        } as LigneBudgetExploitation);
        setError(null);
        return id;
      } catch (err) {
        console.error('Erreur ajout ligne:', err);
        setError('Erreur lors de l\'ajout');
        throw err;
      }
    },
    [siteId]
  );

  // Supprimer une ligne
  const deleteLigne = useCallback(async (id: number) => {
    try {
      await db.budgetExploitation.delete(id);
      setError(null);
    } catch (err) {
      console.error('Erreur suppression ligne:', err);
      setError('Erreur lors de la suppression');
      throw err;
    }
  }, []);

  // Réinitialiser aux valeurs par défaut
  const resetToDefaults = useCallback(async () => {
    try {
      // Supprimer les lignes existantes
      await db.budgetExploitation
        .where('budgetType')
        .equals(budgetType)
        .and((l) => l.annee === annee)
        .delete();

      // Réinsérer les valeurs par défaut
      const now = new Date().toISOString();
      const defaultData = getDefaultData(budgetType, annee);

      if (defaultData.length > 0) {
        const lignesWithTimestamps = defaultData.map((ligne) => ({
          ...ligne,
          siteId,
          createdAt: now,
          updatedAt: now,
        }));

        await db.budgetExploitation.bulkAdd(lignesWithTimestamps as LigneBudgetExploitation[]);
      }

      setError(null);
    } catch (err) {
      console.error('Erreur reset budget:', err);
      setError('Erreur lors de la réinitialisation');
      throw err;
    }
  }, [budgetType, annee, siteId]);

  return {
    lignes: lignes || [],
    isLoading,
    error,
    totaux,
    updateLigne,
    updateMontants,
    addLigne,
    deleteLigne,
    resetToDefaults,
    initializeIfEmpty,
  };
}

export default useBudgetExploitation;

// Export de la fonction de nettoyage des doublons pour utilisation externe
export { cleanupDuplicates };

/**
 * Nettoie tous les doublons de budget exploitation pour tous les types et années
 * Utile pour la maintenance et la réparation de données
 */
export async function cleanupAllBudgetDuplicates(): Promise<{
  totalRemoved: number;
  details: Array<{ budgetType: string; annee: number; removed: number }>;
}> {
  const details: Array<{ budgetType: string; annee: number; removed: number }> = [];
  let totalRemoved = 0;

  // Récupérer toutes les combinaisons uniques de budgetType + annee
  const allLignes = await db.budgetExploitation.toArray();
  const combinations = new Set<string>();

  for (const ligne of allLignes) {
    combinations.add(`${ligne.budgetType}|${ligne.annee}`);
  }

  // Nettoyer chaque combinaison
  for (const combo of combinations) {
    const [budgetType, anneeStr] = combo.split('|');
    const annee = parseInt(anneeStr, 10);
    const removed = await cleanupDuplicates(budgetType as BudgetExploitationType, annee);

    if (removed > 0) {
      details.push({ budgetType, annee, removed });
      totalRemoved += removed;
    }
  }

  if (totalRemoved > 0) {
    console.log(`[Budget] Nettoyage terminé: ${totalRemoved} doublons supprimés au total`);
  }

  return { totalRemoved, details };
}
