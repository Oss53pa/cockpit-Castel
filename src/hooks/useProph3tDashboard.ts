// ============================================================================
// HOOK: useProph3tDashboard
// Agrège les données réelles de la DB pour le dashboard Proph3t
// ============================================================================

import { useMemo } from 'react';
import { useLiveQuery } from 'dexie-react-hooks';
import { db } from '@/db';
import type { Action, Alerte } from '@/types';

// ============================================================================
// TYPES LOCAUX (alignés sur les données réellement construites)
// ============================================================================

export type AlertLevel = 'emergency' | 'critical' | 'warning' | 'info';
export type AlertStatus = 'active' | 'acknowledged' | 'resolved' | 'escalated';

export interface EscalationEvent {
  timestamp: Date;
  fromLevel: string;
  toLevel: string;
  reason?: string;
}

export interface Alert {
  id: string;
  level: AlertLevel;
  title: string;
  message: string;
  source: string;
  sourceId: string;
  module: string;
  timestamp: Date;
  status: AlertStatus;
  acknowledgedAt?: Date;
  resolvedAt?: Date;
  escalationHistory: EscalationEvent[];
  metadata: Record<string, unknown>;
  suggestedActions: string[];
}

export interface AlertSummary {
  total: number;
  byLevel: Record<AlertLevel, number>;
  byStatus: Record<AlertStatus, number>;
  byModule: Record<string, number>;
  criticalCount: number;
  unresolvedCount: number;
  averageResolutionTimeHours: number;
}

export interface ReliabilityHistoryPoint {
  date: Date;
  score: number;
}

export interface ReliabilityScore {
  owner: string;
  overallScore: number;
  components: {
    completionRate: number;
    onTimeRate: number;
    responsiveness: number;
    consistency: number;
  };
  trend: 'improving' | 'stable' | 'declining';
  confidence: number;
  sampleSize: number;
  lastUpdated: Date;
  history: ReliabilityHistoryPoint[];
}

export interface ReliabilityComparison {
  owners: string[];
  scores: Record<string, ReliabilityScore>;
  ranking: Array<{ owner: string; score: number; rank: number }>;
  averageScore: number;
  topPerformer?: string;
  needsAttention: string[];
}

export interface VelocityMetrics {
  currentVelocity: number;
  averageVelocity: number;
  maxVelocity: number;
  minVelocity: number;
  trend: { direction: string; percentage: number; confidence: number };
  weeklyData: unknown[];
  forecastedVelocity: number;
  capacityUtilization: number;
}

export interface TeamVelocity {
  teamName: string;
  currentVelocity: number;
  averageVelocity: number;
  trend: { direction: string; percentage: number; confidence: number };
  members: number;
}

export interface BurnRateMetrics {
  currentBurnRate: number;
  averageBurnRate: number;
  totalBudget: number;
  totalSpent: number;
  remaining: number;
  percentUsed: number;
  burnTrend: { direction: string; percentage: number };
  monthlyData: unknown[];
  runwayMonths: number;
  exhaustionDate: Date;
}

export interface BurnProjection {
  scenario: string;
  exhaustionDate: Date;
  finalSpend: number;
  monthlyRate: number;
  remainingBudget: number;
}

export interface FatigueAssessment {
  overallLevel: string;
  score: number;
  signals: unknown[];
  teamAreas: string[];
  trend: string;
  recommendations: string[];
}

export interface TeamFatigue {
  team: string;
  fatigueLevel: string;
  score: number;
  primaryIndicators: string[];
  recommendation: string;
}

export interface MomentumInsight {
  type: 'positive' | 'negative' | 'neutral';
  message: string;
  impact: string;
}

export interface MomentumAnalysis {
  currentState: string;
  score: number;
  velocity: number;
  acceleration: number;
  dataPoints: unknown[];
  insights: MomentumInsight[];
  forecast: { nextWeek: string; confidence: number; risks: string[] };
}

export interface JournalEntry {
  id: string;
  type: string;
  title: string;
  content: string;
  timestamp: Date;
  importance: string;
  category: string;
  tags: string[];
  isAutoGenerated: boolean;
  author?: string;
}

export interface JournalSummary {
  totalEntries: number;
  byType: Record<string, number>;
  byImportance: Record<string, number>;
  dateRange: { start: Date; end: Date };
  highlights: JournalEntry[];
  trends: unknown[];
}

// ============================================================================
// TYPES — ENGAGEMENTS
// ============================================================================

export interface Commitment {
  id: string;
  title: string;
  description: string;
  owner: string;
  dueDate: Date;
  completedAt?: Date;
  status: 'pending' | 'in_progress' | 'completed' | 'overdue' | 'cancelled';
  priority: 'critical' | 'high' | 'medium' | 'low';
  reminders: Array<{ id: string; scheduledFor: Date; sent: boolean; channel: 'in_app' | 'email' }>;
}

export interface CommitmentStats {
  total: number;
  pending: number;
  inProgress: number;
  completed: number;
  overdue: number;
  completionRate: number;
  avgCompletionTime: number;
}

export interface CommitmentByOwner {
  owner: string;
  stats: { total: number; completed: number; overdue: number; reliabilityScore: number };
}

// ============================================================================
// TYPES — RÉUNIONS
// ============================================================================

export type MeetingType = 'exco' | 'comite_pilotage' | 'point_hebdo' | 'revue_technique' | 'crise' | 'custom';

export interface MeetingPrep {
  meetingType: MeetingType;
  preparedAt: Date;
  summary: {
    headline: string;
    projectHealth: 'green' | 'yellow' | 'red';
    keyMetrics: Array<{ label: string; value: string; trend: 'up' | 'down' | 'stable' }>;
    periodHighlights: string[];
    concerns: string[];
  };
  talkingPoints: Array<{
    id: string;
    topic: string;
    context: string;
    suggestedPosition: string;
    priority: 'must_mention' | 'should_mention' | 'nice_to_have';
    relatedEntities: string[];
  }>;
  decisions: Array<{
    id: string;
    question: string;
    context: string;
    options: Array<{ label: string; pros: string[]; cons: string[] }>;
    recommendation?: string;
    impact: 'high' | 'medium' | 'low';
  }>;
  risksToDiscuss: Array<{ risk: { description: string }; reason: string; suggestedAction: string }>;
  alertsOverview: { critical: number; high: number; medium: number };
  suggestedAgenda: Array<{ order: number; title: string; duration: number }>;
}

// ============================================================================
// TYPES — DÉCISIONS
// ============================================================================

export interface DecisionAnalysis {
  context: {
    category: string;
    question: string;
    background: string;
    urgency: 'immediate' | 'this_week' | 'this_month' | 'when_possible';
    stakeholders: string[];
    constraints: string[];
    objectives: string[];
  };
  options: Array<{
    id: string;
    name: string;
    description: string;
    pros: string[];
    cons: string[];
    risks: string[];
    estimatedCost: number;
    estimatedDuration: number;
    feasibility: 'high' | 'medium' | 'low';
    alignment: number;
  }>;
  recommendation: { optionId: string; confidence: number; rationale: string };
  tradeoffs: Array<{ factor: string; optionA: string; optionB: string; winner: string }>;
  nextSteps: string[];
  deadline?: Date;
}

// ============================================================================
// TYPES — RÉTRO-PLANNING
// ============================================================================

export interface RetroplanItem {
  id: string;
  type: 'jalon' | 'action';
  name: string;
  originalDate: Date;
  currentDate: Date;
  variance: number;
  dependencies: string[];
  dependents: string[];
  isCriticalPath: boolean;
  status: 'on_track' | 'at_risk' | 'delayed' | 'completed';
  floatDays: number;
}

export interface RetroPlan {
  id: string;
  name: string;
  targetDate: Date;
  items: RetroplanItem[];
  criticalPath: string[];
  totalFloat: number;
  healthScore: number;
  lastUpdated: Date;
  version: number;
}

export interface CriticalPathAnalysis {
  path: RetroplanItem[];
  totalDuration: number;
  bottlenecks: Array<{ item: RetroplanItem; reason: string; impact: number }>;
  recommendations: string[];
}

export interface PlanningScenario {
  name: string;
  description: string;
  adjustments: Array<{ itemId: string; oldDate: Date; newDate: Date; reason: string; cascadeEffect: string[]; approved: boolean }>;
  resultingEndDate: Date;
  healthScore: number;
  feasibility: 'high' | 'medium' | 'low';
}

// ============================================================================
// TYPES — NOTIFICATIONS
// ============================================================================

export interface ProNotification {
  id: string;
  title: string;
  message: string;
  priority: 'low' | 'normal' | 'high' | 'urgent';
  status: 'pending' | 'sent' | 'delivered' | 'read' | 'failed';
  createdAt: Date;
  actions?: Array<{ id: string; label: string; action: string; primary?: boolean }>;
}

// ============================================================================
// INTERFACE PRINCIPALE
// ============================================================================

export interface Proph3tDashboardData {
  isLoading: boolean;
  alerts: Alert[];
  alertSummary: AlertSummary;
  reliabilityScores: Record<string, ReliabilityScore>;
  reliabilityComparison: ReliabilityComparison;
  velocityMetrics: VelocityMetrics;
  teamVelocity: TeamVelocity[];
  burnRateMetrics: BurnRateMetrics;
  burnProjections: BurnProjection[];
  fatigueAssessment: FatigueAssessment;
  teamFatigue: TeamFatigue[];
  momentumAnalysis: MomentumAnalysis;
  journalEntries: JournalEntry[];
  journalSummary: JournalSummary;
  globalStats: {
    actionsTotal: number;
    actionsTerminees: number;
    actionsEnRetard: number;
    actionsBloquees: number;
    jalonsTotal: number;
    jalonsAtteints: number;
    jalonsEnRetard: number;
    budgetTotal: number;
    budgetConsomme: number;
    risquesActifs: number;
    risquesCritiques: number;
  };
  // Nouveaux modules
  commitments: Commitment[];
  commitmentStats: CommitmentStats;
  commitmentsByOwner: CommitmentByOwner[];
  meetingPrep: MeetingPrep;
  decisionAnalysis: DecisionAnalysis | null;
  retroPlan: RetroPlan;
  criticalPathAnalysis: CriticalPathAnalysis;
  planningScenarios: PlanningScenario[];
  notifications: ProNotification[];
}

// ============================================================================
// HELPERS
// ============================================================================

function mapCriticiteToLevel(criticite: string): AlertLevel {
  switch (criticite) {
    case 'critical': return 'critical';
    case 'high': return 'warning';
    case 'medium': return 'info';
    case 'low': return 'info';
    default: return 'info';
  }
}

function mapAlerteToProph3tAlert(alerte: Alerte): Alert {
  return {
    id: String(alerte.id),
    level: mapCriticiteToLevel(alerte.criticite),
    title: alerte.titre,
    message: alerte.message,
    source: 'threshold',
    sourceId: String(alerte.entiteId || ''),
    module: alerte.entiteType || 'General',
    timestamp: new Date(alerte.createdAt),
    status: alerte.traitee ? 'resolved' : (alerte.lu ? 'acknowledged' : 'active') as AlertStatus,
    acknowledgedAt: alerte.lu ? new Date(alerte.createdAt) : undefined,
    resolvedAt: alerte.traitee && alerte.traiteeAt ? new Date(alerte.traiteeAt) : undefined,
    escalationHistory: [],
    metadata: {},
    suggestedActions: [],
  };
}

function getOwnerFromAction(action: Action): string {
  return action.responsable || 'Non assigné';
}

function calculateReliabilityForOwner(
  owner: string,
  actions: Action[]
): ReliabilityScore {
  const ownerActions = actions.filter(a => getOwnerFromAction(a) === owner);
  const total = ownerActions.length;

  if (total === 0) {
    return {
      owner,
      overallScore: 50,
      components: { completionRate: 50, onTimeRate: 50, responsiveness: 50, consistency: 50 },
      trend: 'stable',
      confidence: 0.1,
      sampleSize: 0,
      lastUpdated: new Date(),
      history: [],
    };
  }

  const completed = ownerActions.filter(a => a.statut === 'termine').length;
  const completionRate = (completed / total) * 100;

  // On time = terminées avant ou à la date prévue
  const onTime = ownerActions.filter(a => {
    if (a.statut !== 'termine' || !a.date_fin_reelle || !a.date_fin_prevue) return false;
    return new Date(a.date_fin_reelle) <= new Date(a.date_fin_prevue);
  }).length;
  const onTimeRate = completed > 0 ? (onTime / completed) * 100 : 50;

  // Responsiveness = inverse des actions bloquées
  const blocked = ownerActions.filter(a => a.statut === 'bloque').length;
  const responsiveness = Math.max(0, 100 - (blocked / total) * 100);

  // Consistency = écart type de l'avancement (inversé)
  const avancements = ownerActions.map(a => a.avancement || 0);
  const avgAvancement = avancements.reduce((a, b) => a + b, 0) / avancements.length;
  const variance = avancements.reduce((acc, val) => acc + Math.pow(val - avgAvancement, 2), 0) / avancements.length;
  const stdDev = Math.sqrt(variance);
  const consistency = Math.max(0, 100 - stdDev);

  const overallScore = (completionRate * 0.4 + onTimeRate * 0.3 + responsiveness * 0.2 + consistency * 0.1);

  return {
    owner,
    overallScore: Math.round(overallScore),
    components: {
      completionRate: Math.round(completionRate),
      onTimeRate: Math.round(onTimeRate),
      responsiveness: Math.round(responsiveness),
      consistency: Math.round(consistency),
    },
    trend: 'stable',
    confidence: Math.min(0.9, total / 10),
    sampleSize: total,
    lastUpdated: new Date(),
    history: [],
  };
}

// ============================================================================
// HOOK PRINCIPAL
// ============================================================================

export function useProph3tDashboard(): Proph3tDashboardData {
  // Récupérer les données brutes de la DB
  const actionsData = useLiveQuery(() => db.actions.toArray());
  const jalonsData = useLiveQuery(() => db.jalons.toArray());
  const alertesData = useLiveQuery(() => db.alertes.toArray());
  const budgetData = useLiveQuery(() => db.budget.toArray());
  const risquesData = useLiveQuery(() => db.risques.toArray());

  return useMemo(() => {
    const actions = actionsData ?? [];
    const jalons = jalonsData ?? [];
    const alertes = alertesData ?? [];
    const budget = budgetData ?? [];
    const risques = risquesData ?? [];

    const isLoading = actionsData === undefined;

    // ========================================================================
    // STATS GLOBALES
    // ========================================================================
    const today = new Date();
    const actionsEnRetard = actions.filter(a => {
      if (a.statut === 'termine') return false;
      return a.date_fin_prevue && new Date(a.date_fin_prevue) < today;
    });
    const jalonsEnRetard = jalons.filter(j => {
      if (j.statut === 'atteint') return false;
      return j.date_prevue && new Date(j.date_prevue) < today;
    });

    const globalStats = {
      actionsTotal: actions.length,
      actionsTerminees: actions.filter(a => a.statut === 'termine').length,
      actionsEnRetard: actionsEnRetard.length,
      actionsBloquees: actions.filter(a => a.statut === 'bloque').length,
      jalonsTotal: jalons.length,
      jalonsAtteints: jalons.filter(j => j.statut === 'atteint').length,
      jalonsEnRetard: jalonsEnRetard.length,
      budgetTotal: budget.reduce((s, b) => s + (b.montantPrevu || 0), 0),
      budgetConsomme: budget.reduce((s, b) => s + (b.montantRealise || 0), 0),
      risquesActifs: risques.filter(r => r.status !== 'ferme').length,
      risquesCritiques: risques.filter(r => (r.score ?? 0) >= 12).length,
    };

    // ========================================================================
    // ALERTES
    // ========================================================================
    const alerts: Alert[] = alertes.map(mapAlerteToProph3tAlert);

    const alertSummary: AlertSummary = {
      total: alerts.length,
      byLevel: {
        emergency: alerts.filter(a => a.level === 'emergency').length,
        critical: alerts.filter(a => a.level === 'critical').length,
        warning: alerts.filter(a => a.level === 'warning').length,
        info: alerts.filter(a => a.level === 'info').length,
      },
      byStatus: {
        active: alerts.filter(a => a.status === 'active').length,
        acknowledged: alerts.filter(a => a.status === 'acknowledged').length,
        resolved: alerts.filter(a => a.status === 'resolved').length,
        escalated: alerts.filter(a => a.status === 'escalated').length,
      },
      byModule: {},
      criticalCount: alerts.filter(a => a.level === 'critical' || a.level === 'emergency').length,
      unresolvedCount: alerts.filter(a => a.status !== 'resolved').length,
      averageResolutionTimeHours: 12,
    };

    // ========================================================================
    // FIABILITE PAR RESPONSABLE
    // ========================================================================
    const owners = [...new Set(actions.map(getOwnerFromAction))].filter(o => o !== 'Non assigné');
    const reliabilityScores: Record<string, ReliabilityScore> = {};

    for (const owner of owners) {
      reliabilityScores[owner] = calculateReliabilityForOwner(owner, actions);
    }

    const ranking = Object.values(reliabilityScores)
      .sort((a, b) => b.overallScore - a.overallScore)
      .map((score, index) => ({
        owner: score.owner,
        score: score.overallScore,
        rank: index + 1,
      }));

    const avgScore = ranking.length > 0
      ? ranking.reduce((s, r) => s + r.score, 0) / ranking.length
      : 0;

    const reliabilityComparison: ReliabilityComparison = {
      owners,
      scores: reliabilityScores,
      ranking,
      averageScore: Math.round(avgScore),
      topPerformer: ranking[0]?.owner,
      needsAttention: ranking.filter(r => r.score < 60).map(r => r.owner),
    };

    // ========================================================================
    // VELOCITE
    // ========================================================================
    const actionsTermineesRecemment = actions.filter(a => {
      if (a.statut !== 'termine' || !a.date_fin_reelle) return false;
      const finDate = new Date(a.date_fin_reelle);
      const daysAgo = (today.getTime() - finDate.getTime()) / (1000 * 60 * 60 * 24);
      return daysAgo <= 30;
    });

    const weeklyCompleted = actionsTermineesRecemment.length / 4; // ~4 semaines
    const avgAvancement = actions.length > 0
      ? actions.reduce((s, a) => s + (a.avancement || 0), 0) / actions.length
      : 0;

    const velocityMetrics: VelocityMetrics = {
      currentVelocity: Math.round(weeklyCompleted * 10) / 10,
      averageVelocity: Math.round(weeklyCompleted * 10) / 10,
      maxVelocity: Math.round(weeklyCompleted * 1.5 * 10) / 10,
      minVelocity: Math.round(weeklyCompleted * 0.5 * 10) / 10,
      trend: { direction: 'stable', percentage: 0, confidence: 0.7 },
      weeklyData: [],
      forecastedVelocity: Math.round(weeklyCompleted * 10) / 10,
      capacityUtilization: avgAvancement / 100,
    };

    // Vélocité par axe (équipe)
    const axes = [...new Set(actions.map(a => a.axe))];
    const teamVelocity: TeamVelocity[] = axes.map(axe => {
      const axeActions = actions.filter(a => a.axe === axe);
      const completed = axeActions.filter(a => a.statut === 'termine').length;
      const velocity = axeActions.length > 0 ? (completed / axeActions.length) * 5 : 0;

      const axeLabel = axe.replace('axe', 'Axe ').replace('_', ' - ');

      return {
        teamName: axeLabel,
        currentVelocity: Math.round(velocity * 10) / 10,
        averageVelocity: Math.round(velocity * 10) / 10,
        trend: { direction: 'stable' as const, percentage: 0, confidence: 0.7 },
        members: axeActions.length,
      };
    });

    // ========================================================================
    // BURN RATE
    // ========================================================================
    const budgetTotal = globalStats.budgetTotal;
    const budgetConsomme = globalStats.budgetConsomme;
    const percentUsed = budgetTotal > 0 ? Math.round((budgetConsomme / budgetTotal) * 100) : 0;
    const remaining = budgetTotal - budgetConsomme;

    // Estimation simple : 6 mois restants
    const monthlyRate = budgetConsomme / 4; // Basé sur 4 mois écoulés
    const runwayMonths = monthlyRate > 0 ? remaining / monthlyRate : 12;
    const exhaustionDate = new Date();
    exhaustionDate.setMonth(exhaustionDate.getMonth() + Math.floor(runwayMonths));

    const burnRateMetrics: BurnRateMetrics = {
      currentBurnRate: Math.round(monthlyRate),
      averageBurnRate: Math.round(monthlyRate),
      totalBudget: budgetTotal,
      totalSpent: budgetConsomme,
      remaining,
      percentUsed,
      burnTrend: { direction: 'stable', percentage: 0 },
      monthlyData: [],
      runwayMonths: Math.round(runwayMonths * 10) / 10,
      exhaustionDate,
    };

    const burnProjections: BurnProjection[] = [
      {
        scenario: 'optimistic',
        exhaustionDate: new Date(exhaustionDate.getTime() + 60 * 24 * 60 * 60 * 1000),
        finalSpend: budgetTotal * 0.95,
        monthlyRate: monthlyRate * 0.85,
        remainingBudget: budgetTotal * 0.05,
      },
      {
        scenario: 'realistic',
        exhaustionDate,
        finalSpend: budgetTotal,
        monthlyRate,
        remainingBudget: 0,
      },
      {
        scenario: 'pessimistic',
        exhaustionDate: new Date(exhaustionDate.getTime() - 30 * 24 * 60 * 60 * 1000),
        finalSpend: budgetTotal * 1.1,
        monthlyRate: monthlyRate * 1.15,
        remainingBudget: -budgetTotal * 0.1,
      },
    ];

    // ========================================================================
    // FATIGUE & MOMENTUM
    // ========================================================================
    const blockedRatio = actions.length > 0 ? globalStats.actionsBloquees / actions.length : 0;
    const overdueRatio = actions.length > 0 ? globalStats.actionsEnRetard / actions.length : 0;
    const fatigueScore = Math.round((blockedRatio + overdueRatio) * 50);

    const fatigueAssessment: FatigueAssessment = {
      overallLevel: fatigueScore > 50 ? 'high' : fatigueScore > 25 ? 'moderate' : 'low',
      score: fatigueScore,
      signals: [],
      teamAreas: axes.filter(a => {
        const axeActions = actions.filter(act => act.axe === a);
        const blocked = axeActions.filter(act => act.statut === 'bloque').length;
        return blocked > 0;
      }),
      trend: 'stable',
      recommendations: fatigueScore > 25 ? [
        'Identifier les causes de blocage',
        'Prioriser le déblocage des actions critiques',
      ] : [],
    };

    const teamFatigue: TeamFatigue[] = axes.slice(0, 3).map(axe => {
      const axeActions = actions.filter(a => a.axe === axe);
      const blocked = axeActions.filter(a => a.statut === 'bloque').length;
      const score = axeActions.length > 0 ? Math.round((blocked / axeActions.length) * 100) : 0;

      return {
        team: axe.replace('axe', 'Axe ').replace('_', ' - '),
        fatigueLevel: score > 50 ? 'high' : score > 25 ? 'moderate' : 'low',
        score,
        primaryIndicators: blocked > 0 ? ['overdue_accumulation'] : [],
        recommendation: score > 50 ? 'Action urgente requise' : score > 25 ? 'Surveillance recommandée' : 'Aucune action nécessaire',
      };
    });

    // Momentum basé sur avancement global
    const momentumScore = Math.round(avgAvancement);
    const momentumAnalysis: MomentumAnalysis = {
      currentState: momentumScore > 70 ? 'cruising' : momentumScore > 40 ? 'slowing' : 'stalling',
      score: momentumScore,
      velocity: velocityMetrics.currentVelocity,
      acceleration: 0,
      dataPoints: [],
      insights: [
        {
          type: momentumScore > 50 ? 'positive' : 'neutral',
          message: `Avancement global à ${momentumScore}%`,
          impact: momentumScore > 70 ? 'Bonne progression' : 'Progression à surveiller',
        },
      ],
      forecast: {
        nextWeek: momentumScore > 50 ? 'cruising' : 'slowing',
        confidence: 0.7,
        risks: globalStats.actionsBloquees > 0 ? [`${globalStats.actionsBloquees} action(s) bloquée(s)`] : [],
      },
    };

    // ========================================================================
    // JOURNAL (basé sur alertes récentes)
    // ========================================================================
    const journalEntries: JournalEntry[] = alertes
      .slice(0, 20)
      .map(a => ({
        id: `je-${a.id}`,
        type: a.type === 'action_bloquee' ? 'action_blocked' :
              a.type === 'jalon_approche' ? 'schedule_alert' :
              a.type === 'risque_critique' ? 'risk_identified' :
              a.type === 'depassement_budget' ? 'budget_alert' :
              'manual_note',
        title: a.titre,
        content: a.message,
        timestamp: new Date(a.createdAt),
        importance: a.criticite === 'critical' ? 'critical' :
                    a.criticite === 'high' ? 'high' :
                    a.criticite === 'medium' ? 'medium' : 'low',
        category: a.entiteType || 'general',
        tags: [a.type],
        isAutoGenerated: true,
      }));

    const journalSummary: JournalSummary = {
      totalEntries: journalEntries.length,
      byType: {
        milestone_completed: 0,
        milestone_delayed: 0,
        action_completed: 0,
        action_blocked: journalEntries.filter(e => e.type === 'action_blocked').length,
        risk_identified: journalEntries.filter(e => e.type === 'risk_identified').length,
        risk_mitigated: 0,
        decision_made: 0,
        issue_raised: 0,
        issue_resolved: 0,
        budget_alert: journalEntries.filter(e => e.type === 'budget_alert').length,
        schedule_alert: journalEntries.filter(e => e.type === 'schedule_alert').length,
        team_update: 0,
        external_event: 0,
        lesson_learned: 0,
        manual_note: journalEntries.filter(e => e.type === 'manual_note').length,
      },
      byImportance: {
        critical: journalEntries.filter(e => e.importance === 'critical').length,
        high: journalEntries.filter(e => e.importance === 'high').length,
        medium: journalEntries.filter(e => e.importance === 'medium').length,
        low: journalEntries.filter(e => e.importance === 'low').length,
      },
      dateRange: {
        start: journalEntries.length > 0 ? journalEntries[journalEntries.length - 1].timestamp : new Date(),
        end: journalEntries.length > 0 ? journalEntries[0].timestamp : new Date(),
      },
      highlights: journalEntries.filter(e => e.importance === 'critical' || e.importance === 'high').slice(0, 3),
      trends: [],
    };

    // ========================================================================
    // ENGAGEMENTS (dérivés des actions)
    // ========================================================================
    const commitments: Commitment[] = actions
      .filter(a => a.statut !== 'termine' && a.date_fin_prevue)
      .slice(0, 30)
      .map(a => {
        const dueDate = new Date(a.date_fin_prevue!);
        const isOverdue = dueDate < today && a.statut !== 'termine';
        return {
          id: `cmt-${a.id}`,
          title: a.titre || `Action #${a.id}`,
          description: a.description || '',
          owner: a.responsable || 'Non assigné',
          dueDate,
          status: a.statut === 'termine' ? 'completed' as const
               : a.statut === 'bloque' ? 'overdue' as const
               : isOverdue ? 'overdue' as const
               : a.statut === 'en_cours' ? 'in_progress' as const
               : 'pending' as const,
          priority: a.priorite === 'critique' ? 'critical' as const
                  : a.priorite === 'haute' ? 'high' as const
                  : a.priorite === 'moyenne' ? 'medium' as const
                  : 'low' as const,
          reminders: [],
        };
      });

    const commitmentStats: CommitmentStats = {
      total: commitments.length,
      pending: commitments.filter(c => c.status === 'pending').length,
      inProgress: commitments.filter(c => c.status === 'in_progress').length,
      completed: commitments.filter(c => c.status === 'completed').length,
      overdue: commitments.filter(c => c.status === 'overdue').length,
      completionRate: commitments.length > 0
        ? (commitments.filter(c => c.status === 'completed').length / commitments.length) * 100
        : 0,
      avgCompletionTime: 14,
    };

    const commitmentsByOwner: CommitmentByOwner[] = owners.map(owner => {
      const ownerCommitments = commitments.filter(c => c.owner === owner);
      const completed = ownerCommitments.filter(c => c.status === 'completed').length;
      const overdue = ownerCommitments.filter(c => c.status === 'overdue').length;
      return {
        owner,
        stats: {
          total: ownerCommitments.length,
          completed,
          overdue,
          reliabilityScore: ownerCommitments.length > 0
            ? Math.round(((completed / ownerCommitments.length) * 100) - (overdue * 5))
            : 100,
        },
      };
    });

    // ========================================================================
    // PRÉPARATION RÉUNION (synthèse automatique)
    // ========================================================================
    const overdueCount = globalStats.actionsEnRetard;
    const blockedCount = globalStats.actionsBloquees;
    const projectHealth = overdueCount > actions.length * 0.2 ? 'red' as const
                        : overdueCount > actions.length * 0.1 ? 'yellow' as const
                        : 'green' as const;

    const talkingPoints: MeetingPrep['talkingPoints'] = [];
    if (blockedCount > 0) {
      talkingPoints.push({
        id: 'tp-blocages',
        topic: 'Points de blocage',
        context: `${blockedCount} action(s) bloquée(s) nécessitant une décision`,
        suggestedPosition: 'Demander arbitrage ou ressources pour débloquer',
        priority: 'must_mention',
        relatedEntities: [],
      });
    }
    const imminentJalons = jalons.filter(j =>
      j.statut !== 'atteint' && j.date_prevue &&
      new Date(j.date_prevue) < new Date(today.getTime() + 14 * 24 * 60 * 60 * 1000)
    );
    if (imminentJalons.length > 0) {
      talkingPoints.push({
        id: 'tp-jalons',
        topic: 'Jalons imminents',
        context: `${imminentJalons.length} jalon(s) prévu(s) dans les 2 prochaines semaines`,
        suggestedPosition: 'Confirmer la tenue des dates ou alerter sur les risques',
        priority: 'must_mention',
        relatedEntities: [],
      });
    }
    if (overdueCount > 0) {
      talkingPoints.push({
        id: 'tp-retards',
        topic: 'Actions en retard',
        context: `${overdueCount} action(s) en retard de livraison`,
        suggestedPosition: 'Présenter les causes et le plan de rattrapage',
        priority: 'should_mention',
        relatedEntities: [],
      });
    }
    if (globalStats.risquesCritiques > 0) {
      talkingPoints.push({
        id: 'tp-risques',
        topic: 'Risques critiques',
        context: `${globalStats.risquesCritiques} risque(s) de niveau critique`,
        suggestedPosition: 'Présenter les plans de mitigation',
        priority: 'must_mention',
        relatedEntities: [],
      });
    }

    const meetingDecisions: MeetingPrep['decisions'] = actions
      .filter(a => a.statut === 'bloque')
      .slice(0, 3)
      .map(a => ({
        id: `dec-${a.id}`,
        question: `Comment débloquer "${a.titre}" ?`,
        context: a.description || 'Action bloquée nécessitant une décision',
        options: [
          { label: 'Allouer ressources', pros: ['Résolution rapide'], cons: ['Coût additionnel'] },
          { label: 'Réduire le scope', pros: ['Maintien délai'], cons: ['Fonctionnalité réduite'] },
          { label: 'Reporter', pros: ['Pas de surcoût'], cons: ['Impact planning'] },
        ],
        impact: 'high' as const,
      }));

    const risksToDiscuss: MeetingPrep['risksToDiscuss'] = risques
      .filter(r => r.status !== 'ferme' && (r.score ?? 0) >= 9)
      .sort((a, b) => (b.score ?? 0) - (a.score ?? 0))
      .slice(0, 5)
      .map(r => ({
        risk: { description: r.description || r.titre || 'Risque sans description' },
        reason: (r.score ?? 0) >= 15
          ? 'Criticité maximale — attention immédiate'
          : 'Risque élevé nécessitant un suivi rapproché',
        suggestedAction: r.plan_mitigation || 'Définir un plan de mitigation',
      }));

    const pctActions = globalStats.actionsTotal > 0
      ? Math.round((globalStats.actionsTerminees / globalStats.actionsTotal) * 100)
      : 0;

    const meetingPrep: MeetingPrep = {
      meetingType: 'comite_pilotage',
      preparedAt: new Date(),
      summary: {
        headline: projectHealth === 'green' ? 'Projet sous contrôle — Trajectoire nominale'
                : projectHealth === 'yellow' ? 'Vigilance requise — Points d\'attention identifiés'
                : 'Alerte projet — Actions correctives nécessaires',
        projectHealth,
        keyMetrics: [
          { label: 'Avancement actions', value: `${pctActions}%`, trend: 'stable' },
          { label: 'Actions en retard', value: `${overdueCount}`, trend: overdueCount > 0 ? 'down' : 'stable' },
          { label: 'Jalons atteints', value: `${globalStats.jalonsAtteints}/${globalStats.jalonsTotal}`, trend: 'stable' },
          { label: 'Budget consommé', value: `${percentUsed}%`, trend: 'stable' },
        ],
        periodHighlights: actionsTermineesRecemment.length > 0
          ? [`${actionsTermineesRecemment.length} action(s) terminée(s) ce mois`]
          : [],
        concerns: [
          ...(overdueCount > 0 ? [`${overdueCount} action(s) en retard`] : []),
          ...(globalStats.risquesCritiques > 0 ? [`${globalStats.risquesCritiques} risque(s) critique(s)`] : []),
        ],
      },
      talkingPoints,
      decisions: meetingDecisions,
      risksToDiscuss,
      alertsOverview: {
        critical: alertSummary.byLevel.critical,
        high: alertSummary.byLevel.warning,
        medium: alertSummary.byLevel.info,
      },
      suggestedAgenda: [
        { order: 1, title: 'Avancement global', duration: 20 },
        { order: 2, title: 'Budget et planning', duration: 20 },
        { order: 3, title: 'Risques et alertes', duration: 15 },
        { order: 4, title: 'Points d\'arbitrage', duration: 25 },
        { order: 5, title: 'Plan d\'action', duration: 10 },
      ],
    };

    // ========================================================================
    // ANALYSE DE DÉCISION (basée sur les blocages)
    // ========================================================================
    const blockedActions = actions.filter(a => a.statut === 'bloque');
    let decisionAnalysis: DecisionAnalysis | null = null;

    if (blockedActions.length > 0) {
      decisionAnalysis = {
        context: {
          category: 'schedule',
          question: `Comment débloquer les ${blockedActions.length} action(s) bloquée(s) ?`,
          background: `Le projet compte ${blockedActions.length} action(s) bloquée(s), impactant la vélocité globale et les jalons associés.`,
          urgency: blockedActions.length > 3 ? 'immediate' : 'this_week',
          stakeholders: [...new Set(blockedActions.map(a => a.responsable).filter(Boolean) as string[])],
          constraints: ['Budget limité', 'Échéances contractuelles'],
          objectives: ['Maintenir le planning', 'Préserver la qualité'],
        },
        options: [
          {
            id: 'opt-1',
            name: 'Allouer ressources supplémentaires',
            description: 'Mobiliser des ressources additionnelles pour débloquer les actions',
            pros: ['Résolution rapide', 'Maintien du planning'],
            cons: ['Coût additionnel', 'Disponibilité incertaine'],
            risks: ['Surcharge d\'autres équipes'],
            estimatedCost: 0,
            estimatedDuration: 7,
            feasibility: 'medium',
            alignment: 70,
          },
          {
            id: 'opt-2',
            name: 'Réorganiser les priorités',
            description: 'Redéfinir l\'ordre des tâches pour contourner les blocages',
            pros: ['Pas de surcoût', 'Adaptabilité'],
            cons: ['Décalage possible', 'Complexité de coordination'],
            risks: ['Effets domino'],
            estimatedCost: 0,
            estimatedDuration: 3,
            feasibility: 'high',
            alignment: 80,
          },
          {
            id: 'opt-3',
            name: 'Escalader aux décideurs',
            description: 'Remonter les blocages au comité pour arbitrage',
            pros: ['Décisions autorisées', 'Visibilité managériale'],
            cons: ['Délai d\'arbitrage', 'Dépendance hiérarchique'],
            risks: ['Lenteur du processus'],
            estimatedCost: 0,
            estimatedDuration: 14,
            feasibility: 'high',
            alignment: 60,
          },
        ],
        recommendation: {
          optionId: 'opt-2',
          confidence: 75,
          rationale: '"Réorganiser les priorités" est recommandée car elle est hautement faisable, sans coût supplémentaire, et offre le meilleur alignement avec les objectifs.',
        },
        tradeoffs: [
          { factor: 'Coût', optionA: 'Allouer ressources', optionB: 'Réorganiser priorités', winner: 'Réorganiser priorités' },
          { factor: 'Délai', optionA: 'Allouer ressources', optionB: 'Réorganiser priorités', winner: 'Réorganiser priorités' },
          { factor: 'Faisabilité', optionA: 'Allouer ressources', optionB: 'Réorganiser priorités', winner: 'Réorganiser priorités' },
          { factor: 'Risques', optionA: 'Allouer ressources', optionB: 'Réorganiser priorités', winner: 'Allouer ressources' },
        ],
        nextSteps: [
          'Identifier les dépendances des actions bloquées',
          'Proposer un reséquencement au prochain point hebdo',
          'Documenter la décision et le rationale',
        ],
        deadline: new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000),
      };
    }

    // ========================================================================
    // RÉTRO-PLANNING (basé sur jalons + actions)
    // ========================================================================
    const softOpeningDate = new Date('2026-12-01');
    const retroItems: RetroplanItem[] = [];

    // Ajouter les jalons
    jalons.forEach(j => {
      const prevue = j.date_prevue ? new Date(j.date_prevue) : softOpeningDate;
      const variance = j.statut === 'atteint' ? 0
        : prevue < today ? Math.ceil((today.getTime() - prevue.getTime()) / (1000 * 60 * 60 * 24))
        : 0;
      retroItems.push({
        id: `j-${j.id}`,
        type: 'jalon',
        name: j.titre || `Jalon #${j.id}`,
        originalDate: prevue,
        currentDate: prevue,
        variance,
        dependencies: [],
        dependents: [],
        isCriticalPath: variance > 0 || (j.projectPhase === 'phase1_preparation'),
        status: j.statut === 'atteint' ? 'completed'
             : variance > 7 ? 'delayed'
             : variance > 0 ? 'at_risk'
             : 'on_track',
        floatDays: Math.max(0, 30 - variance),
      });
    });

    // Ajouter les actions principales
    actions.filter(a => a.date_fin_prevue).slice(0, 30).forEach(a => {
      const prevue = new Date(a.date_fin_prevue!);
      const variance = a.statut === 'termine' ? 0
        : prevue < today ? Math.ceil((today.getTime() - prevue.getTime()) / (1000 * 60 * 60 * 24))
        : 0;
      retroItems.push({
        id: `a-${a.id}`,
        type: 'action',
        name: a.titre || `Action #${a.id}`,
        originalDate: prevue,
        currentDate: prevue,
        variance,
        dependencies: [],
        dependents: [],
        isCriticalPath: false,
        status: a.statut === 'termine' ? 'completed'
             : a.statut === 'bloque' ? 'delayed'
             : variance > 3 ? 'delayed'
             : variance > 0 ? 'at_risk'
             : 'on_track',
        floatDays: Math.max(0, 14 - variance),
      });
    });

    retroItems.sort((a, b) => a.currentDate.getTime() - b.currentDate.getTime());

    const criticalItems = retroItems.filter(i => i.isCriticalPath);
    const delayedItems = retroItems.filter(i => i.status === 'delayed');
    const atRiskItems = retroItems.filter(i => i.status === 'at_risk');
    const totalFloat = retroItems.reduce((s, i) => s + i.floatDays, 0);
    const healthScore = retroItems.length > 0
      ? Math.round(100 - (delayedItems.length / retroItems.length) * 60 - (atRiskItems.length / retroItems.length) * 20)
      : 100;

    const retroPlan: RetroPlan = {
      id: 'retro-main',
      name: 'Rétro-planning Soft Opening',
      targetDate: softOpeningDate,
      items: retroItems,
      criticalPath: criticalItems.map(i => i.id),
      totalFloat,
      healthScore: Math.max(0, healthScore),
      lastUpdated: new Date(),
      version: 1,
    };

    const criticalPathAnalysis: CriticalPathAnalysis = {
      path: criticalItems.slice(0, 10),
      totalDuration: Math.ceil((softOpeningDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)),
      bottlenecks: delayedItems
        .filter(i => i.isCriticalPath)
        .slice(0, 3)
        .map(i => ({
          item: i,
          reason: i.variance > 14 ? 'Retard critique' : 'En retard',
          impact: i.variance,
        })),
      recommendations: [
        ...(delayedItems.length > 0 ? [`Traiter en priorité les ${delayedItems.length} éléments en retard`] : []),
        ...(atRiskItems.length > 0 ? [`Surveiller les ${atRiskItems.length} éléments à risque`] : []),
        'Maintenir les réunions de suivi hebdomadaires',
      ],
    };

    const planningScenarios: PlanningScenario[] = [
      {
        name: 'Optimiste',
        description: 'Rattrapage de tous les retards en 2 semaines',
        adjustments: [],
        resultingEndDate: softOpeningDate,
        healthScore: 90,
        feasibility: 'low',
      },
      {
        name: 'Réaliste',
        description: 'Rattrapage partiel, décalage modéré',
        adjustments: [],
        resultingEndDate: new Date(softOpeningDate.getTime() + 30 * 24 * 60 * 60 * 1000),
        healthScore: 70,
        feasibility: 'high',
      },
      {
        name: 'Pessimiste',
        description: 'Accumulation des retards, décalage significatif',
        adjustments: [],
        resultingEndDate: new Date(softOpeningDate.getTime() + 90 * 24 * 60 * 60 * 1000),
        healthScore: 40,
        feasibility: 'high',
      },
    ];

    // ========================================================================
    // NOTIFICATIONS (dérivées des alertes)
    // ========================================================================
    const notifications: ProNotification[] = alerts
      .filter(a => a.status !== 'resolved')
      .slice(0, 20)
      .map(a => ({
        id: `notif-${a.id}`,
        title: a.title,
        message: a.message,
        priority: a.level === 'emergency' ? 'urgent' as const
               : a.level === 'critical' ? 'high' as const
               : a.level === 'warning' ? 'normal' as const
               : 'low' as const,
        status: a.status === 'acknowledged' ? 'read' as const : 'delivered' as const,
        createdAt: a.timestamp,
        actions: a.suggestedActions.length > 0
          ? [{ id: 'act-1', label: 'Voir détails', action: 'view', primary: true }]
          : undefined,
      }));

    return {
      isLoading,
      alerts,
      alertSummary,
      reliabilityScores,
      reliabilityComparison,
      velocityMetrics,
      teamVelocity,
      burnRateMetrics,
      burnProjections,
      fatigueAssessment,
      teamFatigue,
      momentumAnalysis,
      journalEntries,
      journalSummary,
      globalStats,
      // Nouveaux modules
      commitments,
      commitmentStats,
      commitmentsByOwner,
      meetingPrep,
      decisionAnalysis,
      retroPlan,
      criticalPathAnalysis,
      planningScenarios,
      notifications,
    };
  }, [actionsData, jalonsData, alertesData, budgetData, risquesData]);
}

export default useProph3tDashboard;
